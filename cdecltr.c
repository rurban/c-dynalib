/* "typed return" variant of cdecl */
/* cdecl.h is generated by ./testcall */
#include "cdecl.h"

typedef uint     (*my_func_i)(void);
typedef double   (*my_func_d)(void);
typedef float    (*my_func_f)(void);
#ifdef HAS_LONG_LONG
typedef long long (*my_func_l)(void);
#endif
#ifdef HAS_QUAD
typedef Uquad_t  (*my_func_q)(void);
#endif

enum {
  TR_int,
  TR_uint,
  TR_I32,
  TR_I16,
  TR_char,
  TR_U32,
  TR_U16,
  TR_uchar,
#ifdef HAS_QUAD
  TR_Quad_t,
  TR_Uquad_t,
#endif
#ifdef HAS_LONG_LONG
  TR_longlong_t,
#endif
  TR_float,
  TR_double,
  TR_char_p,
};

typedef union {
  int           v_int;
  uint          v_uint;
  I32           v_I32;
  I16           v_I16;
  char          v_char;
  U32           v_U32;
  U16           v_U16;
  uchar         v_uchar;
#ifdef HAS_QUAD
  Quad_t        v_Quad_t;
  Uquad_t       v_Uquad_t;
#endif
#ifdef HAS_LONG_LONG
  long long     v_longlong;
#endif
  float         v_float;
  double        v_double;
  char_p        v_char_p;
} ret_stru;

/*
 * Convert Perl sub args to C args and pass them to (*func)().
 * Caller cleanup.
 * See http://en.wikipedia.org/wiki/X86_calling_conventions
 */
static int
cdecltr_pray(ax, items, func, tr)
     I32 ax;		/* used by the ST() macro */
     I32 items;
     void *func;
     int tr;		/* type result return */
{
#ifdef USE_THREADS
  dTHR;
#endif
  /* DYNALIB_ARGSTART = 3 because of three locals here? */
  STRLEN arg_len;
  char *arg_scalar, *arg_on_stack;
  register int i;
  ret_stru tmp1;
#if CDECL_ONE_BY_ONE

#if CDECL_REVERSE
  for (i = DYNALIB_ARGSTART; i < items; i++) {
#else  /* ! CDECL_REVERSE */
  for (i = items - 1; i >= DYNALIB_ARGSTART; i--) {
#endif  /* ! CDECL_REVERSE */
    arg_scalar = SvPV(ST(i), arg_len);
    arg_on_stack = alloca(arg_len);
    Copy(arg_scalar, arg_on_stack, arg_len, char);
  }
#else  /* ! CDECL_ONE_BY_ONE */
  STRLEN total_arg_len = 0;

  for (i = items; i-- > DYNALIB_ARGSTART; ) {
    (void) SvPV(ST(i), arg_len);
    /* XXX CDECL_ARG_ALIGN=8 for amd64 */
    total_arg_len += arg_len;
  }
  arg_on_stack = (char *) alloca(total_arg_len);
  arg_on_stack += CDECL_ADJUST;
#if CDECL_REVERSE
  for (i = items - 1; i >= DYNALIB_ARGSTART; i--) {
#else  /* ! CDECL_REVERSE */
  for (i = DYNALIB_ARGSTART; i < items; i++) {
#endif  /* ! CDECL_REVERSE */
    arg_scalar = SvPV(ST(i), arg_len);
#ifdef __x86_64__
    if (arg_len < 8) { 
      /* x86_64 aligns to 8 non zero-filled.
	 http://blogs.msdn.com/oldnewthing/archive/2004/01/14/58579.aspx
      */
      memzero(arg_on_stack, 8);
    }
#endif
    Copy(arg_scalar, arg_on_stack, arg_len, char);
    arg_on_stack += arg_len;
  }
#endif  /* ! CDECL_ONE_BY_ONE */

  /* Cross your fingers. */
  switch(tr) {
    case TR_float:
        tmp1.v_float = (*(my_func_f)func)();
        break;
    case TR_double:
        tmp1.v_double = (*(my_func_d)func)();
        break;
#ifdef HAS_QUAD
    case   TR_Quad_t:
    case   TR_uQuad_t:
        tmp1.v_uQuad_t = (*(my_func_q)func)();
        break;
#endif
#ifdef HAS_LONG_LONG
    case TR_longlong:
        tmp1.v_longlong = (*(my_func_l)func)();
        break;
#endif
    default:
        tmp1.v_int = (*(my_func_i)func)();
  }
  return tmp1;
}

#define cdecltr_CALL(func, type)			\
  (((cdecltr_pray)(ax,items,func,TR_##type)).v_##type)
